import { NextRequest, NextResponse } from 'next/server'

import { and, asc, eq, sql } from 'drizzle-orm'

import { db } from '@/lib/db/drizzle'
import {
  jobMilestones,
  jobPostings,
  jobTasks,
  messages,
  users
} from '@/lib/db/schema'
import { getUser } from '@/services/user'

// GET /api/freelancers/[id]/active-jobs - Get active jobs with detailed information
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params
    const freelancerId = parseInt(id)

    if (isNaN(freelancerId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid freelancer ID' },
        { status: 400 }
      )
    }

    // Check if user is authorized
    const _user = await getUser()
    if (!user || user.id !== freelancerId) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // Get query parameters
    const searchParams = request.nextUrl.searchParams
    const view = searchParams.get('view') || 'active' // active, completed, all
    const sortBy = searchParams.get('sortBy') || 'updated' // updated, deadline, created

    // Build conditions
    const conditions = [eq(jobPostings.freelancerId, freelancerId)]

    if (view === 'active') {
      conditions.push(sql`${jobPostings.status} IN ('in_progress', 'active')`)
    } else if (view === 'completed') {
      conditions.push(eq(jobPostings.status, 'completed'))
    }

    // Get jobs with comprehensive data
    const jobs = await db
      .select({
        id: jobPostings.id,
        title: jobPostings.title,
        description: jobPostings.description,
        status: jobPostings.status,
        budgetType: jobPostings.budgetType,
        budgetMin: jobPostings.budgetMin,
        budgetMax: jobPostings.budgetMax,
        currency: jobPostings.currency,
        deadline: jobPostings.deadline,
        createdAt: jobPostings.createdAt,
        updatedAt: jobPostings.updatedAt,
        client: {
          id: users.id,
          name: users.name,
          email: users.email,
          avatarPath: users.avatarPath
        },
        totalMilestones: sql<number>`(
          SELECT COUNT(*) 
          FROM ${jobMilestones} 
          WHERE ${jobMilestones.jobId} = ${jobPostings.id}
        )`,
        completedMilestones: sql<number>`(
          SELECT COUNT(*) 
          FROM ${jobMilestones} 
          WHERE ${jobMilestones.jobId} = ${jobPostings.id} 
            AND ${jobMilestones.status} = 'approved'
        )`,
        pendingMilestones: sql<number>`(
          SELECT COUNT(*) 
          FROM ${jobMilestones} 
          WHERE ${jobMilestones.jobId} = ${jobPostings.id} 
            AND ${jobMilestones.status} IN ('pending', 'in_progress', 'submitted')
        )`,
        totalTasks: sql<number>`(
          SELECT COUNT(*) 
          FROM ${jobTasks} 
          WHERE ${jobTasks.jobId} = ${jobPostings.id}
        )`,
        completedTasks: sql<number>`(
          SELECT COUNT(*) 
          FROM ${jobTasks} 
          WHERE ${jobTasks.jobId} = ${jobPostings.id} 
            AND ${jobTasks.status} = 'done'
        )`,
        unreadMessages: sql<number>`(
          SELECT COUNT(*) 
          FROM ${messages} 
          WHERE ${messages.jobPostingId} = ${jobPostings.id}
            AND ${messages.senderId} != ${freelancerId}
            AND ${messages.id} > COALESCE(
              (SELECT last_read_message_id 
               FROM message_reads 
               WHERE user_id = ${freelancerId}
                 AND context_type = 'job'
                 AND context_id = CAST(${jobPostings.id} AS VARCHAR)
              ), 0
            )
        )`,
        nextMilestone: sql<{
          id: number
          title: string
          amount: string
          dueDate: Date | null
          status: string
        } | null>`(
          SELECT json_build_object(
            'id', id,
            'title', title,
            'amount', amount,
            'dueDate', due_date,
            'status', status
          )
          FROM ${jobMilestones}
          WHERE ${jobMilestones.jobId} = ${jobPostings.id}
            AND ${jobMilestones.status} IN ('pending', 'in_progress', 'submitted')
          ORDER BY ${jobMilestones.dueDate} ASC NULLS LAST
          LIMIT 1
        )`,
        totalEarned: sql<number>`(
          SELECT COALESCE(SUM(CAST(amount AS DECIMAL)), 0)
          FROM ${jobMilestones}
          WHERE ${jobMilestones.jobId} = ${jobPostings.id}
            AND ${jobMilestones.status} = 'approved'
        )`,
        totalPending: sql<number>`(
          SELECT COALESCE(SUM(CAST(amount AS DECIMAL)), 0)
          FROM ${jobMilestones}
          WHERE ${jobMilestones.jobId} = ${jobPostings.id}
            AND ${jobMilestones.status} IN ('pending', 'in_progress', 'submitted')
        )`
      })
      .from(jobPostings)
      .leftJoin(users, eq(jobPostings.clientId, users.id))
      .where(and(...conditions))

    // Sort results
    let sortedJobs = jobs
    switch (sortBy) {
      case 'deadline':
        sortedJobs = jobs.sort((a, b) => {
          if (!a.deadline) return 1
          if (!b.deadline) return -1
          return new Date(a.deadline).getTime() - new Date(b.deadline).getTime()
        })
        break
      case 'created':
        sortedJobs = jobs.sort(
          (a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )
        break
      case 'updated':
      default:
        sortedJobs = jobs.sort(
          (a, b) =>
            new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
        )
        break
    }

    // Get milestones for active jobs
    const activeJobIds = sortedJobs
      .filter(j => j.status === 'in_progress' || j.status === 'active')
      .map(j => j.id)

    let milestones: any[] = []
    if (activeJobIds.length > 0) {
      milestones = await db
        .select({
          id: jobMilestones.id,
          jobId: jobMilestones.jobId,
          title: jobMilestones.title,
          amount: jobMilestones.amount,
          dueDate: jobMilestones.dueDate,
          status: jobMilestones.status,
          submittedAt: jobMilestones.submittedAt,
          approvedAt: jobMilestones.approvedAt,
          autoReleaseEnabled: jobMilestones.autoReleaseEnabled,
          jobTitle: sql<string>`(
            SELECT title FROM ${jobPostings} WHERE id = ${jobMilestones.jobId}
          )`
        })
        .from(jobMilestones)
        .where(sql`${jobMilestones.jobId} = ANY(${activeJobIds})`)
        .orderBy(asc(jobMilestones.dueDate))
    }

    // Get upcoming deadlines
    const upcomingDeadlines = milestones
      .filter(
        m =>
          m.dueDate &&
          new Date(m.dueDate) > new Date() &&
          ['pending', 'in_progress'].includes(m.status)
      )
      .slice(0, 5)

    // Calculate statistics
    const stats = {
      totalActive: sortedJobs.filter(
        j => j.status === 'in_progress' || j.status === 'active'
      ).length,
      totalCompleted: sortedJobs.filter(j => j.status === 'completed').length,
      totalMilestones: sortedJobs.reduce(
        (acc, j) => acc + Number(j.totalMilestones),
        0
      ),
      completedMilestones: sortedJobs.reduce(
        (acc, j) => acc + Number(j.completedMilestones),
        0
      ),
      totalTasks: sortedJobs.reduce((acc, j) => acc + Number(j.totalTasks), 0),
      completedTasks: sortedJobs.reduce(
        (acc, j) => acc + Number(j.completedTasks),
        0
      ),
      totalEarned: sortedJobs.reduce(
        (acc, j) => acc + Number(j.totalEarned),
        0
      ),
      totalPending: sortedJobs.reduce(
        (acc, j) => acc + Number(j.totalPending),
        0
      ),
      unreadMessages: sortedJobs.reduce(
        (acc, j) => acc + Number(j.unreadMessages),
        0
      )
    }

    // Calculate completion percentage for each job
    const jobsWithProgress = sortedJobs.map(job => ({
      ...job,
      progress:
        Number(job.totalMilestones) > 0
          ? Math.round(
              (Number(job.completedMilestones) / Number(job.totalMilestones)) *
                100
            )
          : 0,
      taskProgress:
        Number(job.totalTasks) > 0
          ? Math.round(
              (Number(job.completedTasks) / Number(job.totalTasks)) * 100
            )
          : 0
    }))

    return NextResponse.json({
      success: true,
      data: {
        jobs: jobsWithProgress,
        milestones,
        upcomingDeadlines,
        stats
      }
    })
  } catch (_error) {
    console.error('Error fetching active jobs:', error)
    return NextResponse.json(
      { success: false, error: 'Failed to fetch active jobs' },
      { status: 500 }
    )
  }
}
